#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Diagnostics;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static (double s, long time) Solve(double a, double b, Func<double, double> function, double step, int threadsNumber)
    {
        double s = function(a) + function(b);
        double n = (b - a) / step;
        double sum = 0;
        var options = new ParallelOptions { MaxDegreeOfParallelism = threadsNumber };
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        Parallel.For(1, (int)n, options, () => 0.0, (i, state, localSum) =>
        {
            double x = a + i * step;
            localSum += 2 * function(x);
            return localSum;
        },
        localSum =>
        {
            double initialValue, computedValue;
            do
            {
                initialValue = sum;
                computedValue = initialValue + localSum;
            } while (Interlocked.CompareExchange(ref sum, computedValue, initialValue) != initialValue);
        });

        s += sum;
        s *= step / 2;
        stopwatch.Stop();
        long time = stopwatch.ElapsedTicks;
        return (s, time);
    }
}

#!csharp

#r "nuget: xunit, 2.8.1"
#r "nuget:ScottPlot, 5.0.35"

using Xunit;
using Microsoft.DotNet.Interactive.Formatting;

Func<double, double> X = x => x;
Func<double, double> SIN = x => Math.Sin(x);
var stopwatch = new Stopwatch();
var threadCount = new List<int>();
var times = new List<long>();

Formatter.Register<ScottPlot.Plot>((plot, writer) => 
    writer.Write(plot.GetImageHtml(600, 600)), HtmlFormatter.MimeType);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2).s, 1e-4);
Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8).s, 1e-4);
Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8).s, 1e-5);
Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, 8).s, 1e-4);

for (int i = 1; i <= 30; i++)
{
    var s = DefiniteIntegral.Solve(-100, 100, SIN, 1e-4, i);
    threadCount.Add(i);
    times.Add(s.time);
    Console.WriteLine($"Количество потоков: {i}, Время: {s.time} ");
}

double[] dataThreads = threadCount.ConvertAll(x => (double)x).ToArray();
double[] dataTimes = times.ConvertAll(x => (double)x).ToArray();

var plot = new ScottPlot.Plot();
plot.Add.Scatter(dataTimes, dataThreads);
plot.Title("Время выполнения в зависимости от количества потоков");
plot.XLabel("Время");
plot.YLabel("Количество потоков");

plot

#!csharp

class TrapezoidalRule {
    public static (double s, long time) Solve(double a, double b, Func<double, double> f, double step, int threadsnumber) {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.Start();
        double s = f(a) + f(b);
        double n = (b-a)/step;
        for (int i  = 0; i < n; i++){
            s += 2*f(a + i * step);
        }
        s *= step/2;
        stopwatch.Stop();
        long time = stopwatch.ElapsedTicks;
        return (s, time);
    }
}

#!markdown

# Summary

Шаг выбран 1-e4, т.к. при проверки на остальных вариантах шагов этот шаг был оптимален.

**Лучший результат многопоточного решения:**

Количество потоков: 25, Время: 158865 

**Результат однопоточного решения:**

Время: 350538

**Сравнение** 

Многопоточный вариант быстрее однопточного на 54%
