#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №9. Реализация длительных операций.

**Цель:** Предоставить возможность выполннеия команд, для полного завершения которых требуется более одного вызова Execute.

**Результаты:** После выполнения работы Вы сможете:
1. Выполнять длительные опреации в отдельном потоке без монопольного использования потока в течение длительного времени.
3. Прерывать выполнение таких команд. 


## Задание.
Если для полного выполнения командв потребуется более одного вызова Execute, необходимо такую команду добавить в планировщик.

Для иллюстрации выполнненой работы определить команду

#!csharp

public interface ICommand
{
    void Execute();
}


public class TestCommand : ICommand
{
    private int id;
    private int counter = 0;

    public TestCommand(int id)
    {
        this.id = id;
    }

    public void Execute()
    {
        Console.WriteLine($"Поток {id} вызов {++counter}");
    }
}

#!csharp

public class CommandScheduler
{
    private Queue<ICommand> commandQueue = new Queue<ICommand>();
    private CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();
    private Task schedulerTask;

    public void AddCommand(ICommand command)
    {
        commandQueue.Enqueue(command);
    }

    public void Start()
    {
        cancellationTokenSource = new CancellationTokenSource();
        schedulerTask = Task.Run(() => RunScheduler(cancellationTokenSource.Token));
    }

    public void HardStop()
    {
        cancellationTokenSource.Cancel();
        try
        {
            schedulerTask.Wait();
        }
        catch (AggregateException)
        {

        }
    }

    private void RunScheduler(CancellationToken cancellationToken)
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            if (commandQueue.Count > 0)
            {
                ICommand command = commandQueue.Dequeue();
                command.Execute();
                commandQueue.Enqueue(command);
                Thread.Sleep(1000);
            }
        }
    }
}

#!csharp

CommandScheduler scheduler = new CommandScheduler();

for (int i = 1; i <= 5; i++)
{
    scheduler.AddCommand(new TestCommand(i));
}

scheduler.Start();

Thread.Sleep(15000);

scheduler.HardStop();

Console.WriteLine("Планировщик остановлен.");

#!markdown

Необходимо проиллюстрировать выполнение 5 экземпляров TestCommand 3 раза, затем остановить поток с помощью HardStop.
